# Apdx-A

## 처음 해보는 성능 테스트를 위한 기본 정리

[목차]
- 성능테스트종류
- 테스트설계고려사항
- 성능테스트도구  
- 실행주의사항


초보자를 위한 성능 테스트 핵심 개념 가이드

도입: 막연한 추측에서 확신으로

"내 서버는 과연 얼마나 많은 트래픽을 감당할 수 있을까?"라는 질문을 한 번쯤 해보셨을 겁니다. 성능 테스트는 바로 이 '막연한 추측을 확신으로 바꾸는 과정'입니다. 이 가이드를 통해 여러분은 시스템의 한계를 명확히 파악하고, 성능 저하의 원인인 병목을 해결하며, 우리 서비스에 대한 기술적 자신감을 구축하는 방법을 배우게 될 것입니다.


--------------------------------------------------------------------------------


1. 성능 테스트란 무엇인가? 핵심 들여다보기

1.1. 성능 테스트의 정의

성능 테스트란 '특정 작업 부하 상태에서 시스템의 응답성과 안정성을 확인하기 위해 수행하는 테스트'입니다.

1.2. 반드시 알아야 할 3가지 핵심 지표

성능 테스트에서는 수많은 데이터를 얻게 되지만, 그중에서도 가장 중요하게 봐야 할 세 가지 핵심 지표가 있습니다.

지표	핵심 설명	왜 중요한가?
응답 시간 (Response Time)	사용자가 요청을 보내고 응답을 받기까지 걸리는 시간	사용자가 서비스가 빠르다고 느끼는 직접적인 척도입니다.
처리량 (Throughput)	단위 시간당 시스템이 처리하는 요청의 수 (예: TPS - Transactions Per Second)	시스템이 동시에 얼마나 많은 사용자를 감당할 수 있는지를 보여줍니다.
자원 사용량 (Resource Usage)	테스트 중 CPU, 메모리, 네트워크 등의 사용률	시스템의 잠재적 한계나 비효율적인 부분을 파악하는 단서가 됩니다.

이제 성능 테스트의 기본 개념을 알았으니, 어떤 목적을 위해 어떤 종류의 테스트를 수행해야 하는지 알아보겠습니다.


--------------------------------------------------------------------------------


2. 목적에 따라 골라 쓰는 4가지 성능 테스트 유형

성능 테스트는 목적에 따라 여러 유형으로 나뉩니다. 가장 대표적인 4가지 유형을 소개합니다.

A. 부하 테스트 (Load Test)

"예상되는 일반적인 부하에서 시스템의 성능 지표(응답 시간, 처리량)를 확인하고 병목을 파악합니다."

* 이 테스트는 이런 질문에 답을 줍니다: "우리 서비스의 평소 트래픽 수준에서 사용자들은 쾌적하게 서비스를 이용할 수 있을까?"

B. 스트레스 테스트 (Stress Test)

"예상을 뛰어넘는 부하를 가해 시스템의 한계점과 최대 성능을 확인합니다."

* 이 테스트는 이런 질문에 답을 줍니다: "예상치 못한 트래픽이 몰렸을 때, 우리 시스템은 어디까지 버틸 수 있을까?"

C. 지속 부하 테스트 (Soak Test)

"장시간 동안 지속적인 부하를 주어 메모리 누수나 성능 저하 여부를 검증합니다."

* 이 테스트는 이런 질문에 답을 줍니다: "서비스를 오랜 시간 운영해도 성능 저하 없이 안정적일까?"

D. 스파이크 테스트 (Spike Test)

"순간적으로 트래픽이 급증할 때 시스템의 반응성과 안정성을 검증합니다."

* 이 테스트는 이런 질문에 답을 줍니다: "블랙 프라이데이처럼 갑자기 사용자가 몰려도 서비스가 다운되지 않을까?"

이러한 테스트를 통해 우리는 시스템의 '한계'를 발견하게 됩니다. 이 한계가 어떻게 나타나는지 시각적으로 이해해 봅시다.


--------------------------------------------------------------------------------


3. 시스템의 한계점: 포화점과 버클 존 이해하기

3.1. 성능의 정점, 포화점 (Saturation Point)

성능 테스트는 일반적으로 낮은 부하(예: 동시 사용자 수)에서 시작해 점진적으로 부하를 높여가며 진행됩니다. 이때 **포화점(Saturation Point)**은 부하가 증가함에 따라 처리량도 함께 증가하다가, 더 이상 처리량이 늘지 않는 최대 성능 지점을 의미합니다. 이 지점이 바로 시스템의 성능 한계입니다.

3.2. 성능 붕괴의 시작, 버클 존 (Buckle Zone)

**버클 존(Buckle Zone)**은 포화점을 지나 부하가 더 증가하면, 오히려 처리량과 응답 시간이 급격히 저하되는 위험 구간입니다. 이 용어는 물리 현상인 '좌굴(Buckling)'에서 유래했습니다. 기둥에 수직으로 하중을 가할 때 어느 순간 하중을 견디지 못하고 휘어지는 것처럼, 시스템이 한계를 초과했을 때 성능이 급격히 무너지는 상황을 비유하는 것입니다.

3.3. 한눈에 보는 성능 붕괴 과정

부하 증가에 따른 시스템의 처리량 변화는 다음과 같은 이야기로 설명할 수 있습니다.

* 초기 구간: 부하(동시 사용자 수)가 증가하면 처리량(TPS)도 함께 선형적으로 증가하는 안정적인 단계입니다.
* 포화점: 시스템이 감당할 수 있는 최대 처리량에 도달한 정점입니다.
* 버클 존: 포화점을 넘어서자 시스템이 부하를 감당하지 못하고 응답 시간 지연과 함께 처리량이 급격히 감소하는 위험 구간입니다.

결론적으로, 우리의 목표는 포화점을 최대한 높이고, 버클 존에 진입하는 것을 방지하는 것입니다.

만약 테스트 결과 포화점이 우리의 목표 성능보다 낮다면, 그 원인인 '병목'을 찾아 해결해야 합니다.


--------------------------------------------------------------------------------


4. 성능 저하의 주범, 병목은 어디서 발생할까?

테스트 결과 포화점이 목표 성능보다 낮다면, 성능을 제한하는 병목 지점을 찾아 제거해야 합니다. 병목은 일반적으로 '호출 비중이 높고 응답 시간이 긴 기능'에서 발생하며, 주요 원인은 다음과 같습니다.

* 🗄️ DB 연동 비효율적인 쿼리 실행 시간, 인덱스 부재 등
* ☁️ 외부 서비스 연동 외부 API의 느린 응답 시간
* 🔗 부족한 커넥션 풀 트래픽 대비 부족한 DB 커넥션 풀 또는 스레드 풀 크기

병목 지점을 찾았다면 서버 확장, 캐시 적용, 비동기 처리 등의 방법으로 응답 시간을 개선하여 포화점을 높일 수 있습니다.


--------------------------------------------------------------------------------


5. 숫자의 함정 피하기: 성능 지표 올바르게 읽기

5.1. '평균'의 함정

성능 지표를 분석할 때 응답 시간의 '평균' 값만 보는 것은 위험합니다. 소수의 매우 느린 요청이 평균값을 크게 높여 전체적인 사용자 경험을 왜곡할 수 있기 때문입니다.

5.2. 진짜 성능을 보여주는 지표들

평균의 함정을 피하고 사용자 경험을 더 정확히 이해하려면 아래 지표들을 함께 확인해야 합니다.

* 최소/최대 (Min/Max): 가장 빠르고 가장 느린 응답 시간을 보여주어 성능의 범위를 파악할 수 있습니다.
* 중앙값 (Median): 모든 응답 시간을 순서대로 나열했을 때 정확히 중앙에 위치하는 값입니다. 평균보다 이상치(outlier)의 영향을 덜 받습니다.
* 백분위 (Percentile - 95%, 99%): 전체 요청 중 95% 또는 99%가 이 시간보다 빠르다는 것을 의미합니다. 소수의 사용자가 겪는 심각한 성능 저하, 즉 롱테일(Long-tail) 문제를 파악하는 데 필수적입니다.

5.3. 분포로 진짜 사용자 경험 파악하기

응답 시간 분포가 오른쪽으로 긴 꼬리를 갖는 **오른쪽 꼬리 분포(right-skewed distribution)**를 보일 때, '평균(Mean)'이 '중앙값(Median)'보다 오른쪽에 위치하게 됩니다. 이는 소수의 매우 느린 요청(outliers)이 전체 평균을 느린 쪽으로 끌어당기고 있다는 강력한 신호입니다. 이 경우, 대부분의 사용자가 실제로 경험하는 응답 시간은 평균보다 빠른 중앙값에 더 가깝습니다.

따라서 심각한 성능 저하를 겪는 소수 사용자의 경험을 놓치지 않으려면, 반드시 95% 또는 99% 백분위 값을 함께 확인하여 꼬리 부분의 성능을 정확히 파악해야 합니다.

이제 지표를 올바르게 읽는 법을 알았으니, 의미 있는 결과를 얻기 위해 테스트를 어떻게 설계해야 할지 알아봅시다.


--------------------------------------------------------------------------------


6. 실전처럼! 의미 있는 테스트를 위한 설계 체크리스트

의미 있는 성능 테스트 결과를 얻으려면, 테스트 시나리오가 실제 운영 환경을 최대한 반영해야 합니다. 다음 5가지 요소를 반드시 고려하여 테스트를 설계하세요.

1. 트래픽 패턴 (Traffic Pattern): 서비스의 실제 트래픽 패턴을 반영해야 합니다. 콜센터 업무 시스템처럼 꾸준한가요, 아니면 학원 관련 서비스처럼 주중 오후에 트래픽이 급증하나요? 패턴에 맞게 부하를 조절해야 합니다.
2. 동시 사용자 수 / 규모 (User Scale): 목표 동시 사용자 수에 맞춰 부하 규모를 설계해야 합니다. 50명이 사용하는 내부 시스템과 1천만 명이 사용하는 온라인 서비스의 테스트 규모는 완전히 다릅니다.
3. 기능별 요청 비율 (API Mix): 실제 호출 비율에 맞게 부하를 분배해야 합니다. 가장 많이 사용되는 기능에 병목이 있을 확률이 높기 때문입니다. 단일 API만 테스트하면 캐시 효과 등으로 인해 결과가 왜곡될 수 있습니다.
4. 데이터 크기 (Data Volume): 실제 운영 환경과 유사한 규모의 데이터로 테스트해야 합니다. 100만 건의 데이터가 예상되는 서비스에 50건의 데이터로 테스트하는 것은 무의미합니다.
5. 워밍업 (Warm-up): 캐시를 사용하는 시스템의 경우, 테스트 시작 전에 캐시를 어느 정도 채우는 '워밍업' 과정이 필요할 수 있습니다. 그렇지 않으면 캐시가 비어있는 상태에서 측정되어 초기 성능이 실제보다 낮게 나올 수 있습니다.


--------------------------------------------------------------------------------


7. 흔하지만 치명적인 실행 단계의 실수들

잘 설계된 테스트도 실행 단계의 실수 하나로 의미 없는 결과가 될 수 있습니다. 다음 4가지 실수는 반드시 피해야 합니다.

7.1. 자원 공유의 함정 (Shared Resources)

* 실수: 부하 발생기와 테스트 대상 서버를 동일한 장비에서 실행하는 것.
* 이유: 부하를 생성하는 작업 자체가 많은 CPU와 메모리 자원을 소모합니다. 이로 인해 테스트 대상 시스템이 사용할 자원이 부족해져 성능이 실제보다 낮게 측정될 뿐만 아니라, 부하 발생기 자체의 성능이 저하되어 계획했던 부하를 시스템에 제대로 전달하지 못할 수도 있습니다. 반드시 물리적으로 분리해야 합니다.

7.2. 서버 설정 무시 (Ignoring Server Limits)

* 실수: Nginx의 IP당 요청 제한(rate limit)이나 작은 스레드 풀 크기 같은 서버 설정을 확인하지 않고 테스트하는 것.
* 이유: 테스트 자체가 서버의 설정에 의해 막혀 시스템에 제대로 된 부하를 전달하지 못하고, 결국 잘못된 결과를 낳게 됩니다.

7.3. 네트워크 간섭 (Network Interference)

* 실수: 실제 운영 시스템과 동일한 네트워크 환경에서 대규모 부하 테스트를 진행하는 것.
* 이유: 테스트로 인해 발생한 막대한 트래픽이 실제 운영 환경의 네트워크에 영향을 주어, 실제 서비스가 먹통이 되는 심각한 장애를 유발할 수 있습니다. 네트워크 환경을 반드시 분리해야 합니다.

7.4. 외부 서비스 공격 (Attacking External Services)

* 실수: 외부 서비스 연동 부분을 그대로 두고 테스트하는 것.
* 이유: 테스트 대상은 우리 시스템이지, 우리가 제어할 수 없는 외부 시스템이 아닙니다. 의도치 않게 외부 시스템에 대규모 부하를 주어 장애를 유발할 수 있습니다. 반드시 가짜(mock) 서비스로 대체해야 합니다.


--------------------------------------------------------------------------------


8. 성능 테스트의 황금률과 도구 선택

8.1. 단 하나의 황금률

수많은 주의사항이 있지만, 성능 테스트의 가장 중요한 원칙 하나를 꼽으라면 바로 이것입니다.

테스트 환경은 실제 운영 환경과 최대한 동일하게 구성해야 합니다.

운영 서버는 8코어 CPU, 16GB 메모리인데 테스트 서버가 2코어, 2GB 메모리라면 그 결과는 아무 의미가 없습니다. 유효한 성능 지표를 얻으려면 하드웨어 사양, 데이터 규모 등 모든 것을 실제 환경에 맞춰야 합니다.

8.2. 당신의 팀에 맞는 도구 선택하기

어떤 도구가 절대적으로 더 좋다기보다는, 각 팀의 기술 스택과 상황에 맞춰 선택하는 것이 중요합니다. 선택의 가장 좋은 기준은 '팀이 가장 익숙한 언어 생태계'입니다.

* JavaScript가 익숙하다면 → k6
* Python이 익숙하다면 → Locust
* JVM (Java, Scala, Kotlin) 환경이 익숙하다면 → Gatling, JMeter


--------------------------------------------------------------------------------


9. 결론: 실패가 아닌, 확신을 구축하는 과정

성능 테스트는 "미션 이해 → 한계점 파악 → 신호 읽기 → 시뮬레이션 설계 → 정밀한 실행"으로 이어지는 체계적인 과정입니다.

마지막으로 기억해야 할 것은, 성능 테스트는 단순히 '실패를 찾는 과정이 아니라, 우리 시스템에 대한 확신을 구축하는 과정'이라는 점입니다. 이제 당신은 성능 테스트의 기본 플레이북을 가졌습니다. 추측이 아닌 데이터에 기반하여 시스템의 성능을 증명하고 개선해 나가시길 바랍니다.
