비동기를 사용할 때 주의할 점 

근본 원인
- 실행 흐름의 분리 및 스레드 독립성, 가장 중요한 이유는 예외(Exception)는 스레드 경계를 넘어 전파되지 않는다는 프로그래밍 언어의 기본적인 원칙 때문이다.

try-catch의 범위
- try-catch 블록은 호출한 스레드 (메인 스레드) 내에서 순차적으로 실행되는 코드의 오류만 포착하도록 설계.

비동기 호출 시점
- 메인 스레드가 try 블록 내에서 별도의 스레드 작업을 호출하면, 메인 스레드는 작업을 시작했다는 사실만 확인하고 즉시 다음으로 넘어간다.

실행 흐름 분리
- 별도 스레드는 메인 스레드와 완전히 독립적인 실행 경로를 가진다. 메인 스레드가 이미 try-catch 블록을 빠져나가 모든 처리를 완료했을 때, 비동기 스레드는 한참 뒤에 작업을 수행하다가 오류를 낼 수 있다.

오류 포착 실패
- 오류가 발생한 시점에는 메인 스레드가 오류가 발생한 스레드의 감시 범위 밖에 있기 때문에, 메인 스레드의 catch 블록은 이 오류를 감지하거나 포착할 수 없다.

대용량 비동기 처리하려면?

플랫폼 스래드의 한계
- 전통적으로 자바의 플랫폼 스레드는 운영체제(OS)의 스레드와 1:1로 맵핑된다. 
- 스레드 오버헤드
* 메모리 소모가 크다.
* OS 커널 레벨에서 발생하는 잦은 컨텍스트 스위칭으로 CPU 자원 낭비가 크다.
- I/O 블로킹 비효율 
* 외부 API 호출, DB 쿼리, 메시지 큐 대기 등 I/O 작업이 주를 이룰 경우 스레드가 데이터를 기다리는 동안 OS 스레드가 놀게되어 자원 활용 효율이 극도로 떨어진다.
* 그로인해 제한된 스레드 풀 크기 때문에 동시 처리량이 낮아진다. 

가상 스레드/고루틴의 장점
- 가상 스레드
* OS 스레드 위에 가상 스레드를 실행하고 관리한다.
* I/O 대기가 발생하면 OS 스레드를 점유하지 않는다.
- 고루틴
* Go 런타임이 OS 스레드 위에 고루틴을 스케줄링하고 관리한다. 
* 가상 스레드와 마찬가지로 OS 스레드와 분리되어 자원을 사용한다.
