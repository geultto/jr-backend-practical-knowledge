1. 별도 스레드로 실행하기
    비동기를 사용할 때 주의할 점 

    근본 원인
    - 실행 흐름의 분리 및 스레드 독립성, 가장 중요한 이유는 예외(Exception)는 스레드 경계를 넘어 전파되지 않는다는 프로그래밍 언어의 기본적인 원칙 때문이다.

    try-catch의 범위
    - try-catch 블록은 호출한 스레드 (메인 스레드) 내에서 순차적으로 실행되는 코드의 오류만 포착하도록 설계.

    비동기 호출 시점
    - 메인 스레드가 try 블록 내에서 별도의 스레드 작업을 호출하면, 메인 스레드는 작업을 시작했다는 사실만 확인하고 즉시 다음으로 넘어간다.

    실행 흐름 분리
    - 별도 스레드는 메인 스레드와 완전히 독립적인 실행 경로를 가진다. 메인 스레드가 이미 try-catch 블록을 빠져나가 모든 처리를 완료했을 때, 비동기 스레드는 한참 뒤에 작업을 수행하다가 오류를 낼 수 있다.

    오류 포착 실패
    - 오류가 발생한 시점에는 메인 스레드가 오류가 발생한 스레드의 감시 범위 밖에 있기 때문에, 메인 스레드의 catch 블록은 이 오류를 감지하거나 포착할 수 없다.

    대용량 비동기 처리하려면?

    플랫폼 스래드의 한계
    - 전통적으로 자바의 플랫폼 스레드는 운영체제(OS)의 스레드와 1:1로 맵핑된다. 
    - 스레드 오버헤드
    * 메모리 소모가 크다.
    * OS 커널 레벨에서 발생하는 잦은 컨텍스트 스위칭으로 CPU 자원 낭비가 크다.
    - I/O 블로킹 비효율 
    * 외부 API 호출, DB 쿼리, 메시지 큐 대기 등 I/O 작업이 주를 이룰 경우 스레드가 데이터를 기다리는 동안 OS 스레드가 놀게되어 자원 활용 효율이 극도로 떨어진다.
    * 그로인해 제한된 스레드 풀 크기 때문에 동시 처리량이 낮아진다. 

    가상 스레드/고루틴의 장점
    - 가상 스레드
    * OS 스레드 위에 가상 스레드를 실행하고 관리한다.
    * I/O 대기가 발생하면 OS 스레드를 점유하지 않는다.
    - 고루틴
    * Go 런타임이 OS 스레드 위에 고루틴을 스케줄링하고 관리한다. 
    * 가상 스레드와 마찬가지로 OS 스레드와 분리되어 자원을 사용한다.

2. 메시징
    1. Kafka (카프카)
    Kafka는 대규모 데이터 스트림 처리에 최적화된 분산 메시징 플랫폼이다.

    장점:
    높은 처리량을 보인다. 초당 백만 개 이상의 메시지 처리가 가능할 정도로 압도적인 성능을 자랑한다.
    수평 확장 용이성이 뛰어나다. 서버(브로커), 파티션, 소비자를 손쉽게 늘려 **수평 확장(Scale-out)**에 매우 유리하다.
    메시지를 디스크에 일정 기간 보존하는 영구 저장소 역할을 한다. 이 덕분에 소비자가 메시지를 놓치거나 처리하지 못했을 경우 **다시 처리(Replay)**할 수 있다.

    단점:
    시스템 구조가 복잡하며, 운영 및 관리에 상대적으로 높은 전문성이 요구된다.

    2. RabbitMQ (래빗MQ)
    RabbitMQ는 메시지 전송의 신뢰성과 복잡한 라우팅에 중점을 둔 전통적인 메시지 브로커이다.

    장점:
    높은 신뢰성을 제공하여 메시지 전달 보장이 중요할 때 유용하다. 다양한 메시지 큐 모델(Exchanges)을 지원한다.

    단점:
    Kafka에 비해 메시지 처리량(Throughput)은 상대적으로 낮다.
    운영 환경에서 **많은 자원(Resource)**을 요구하는 경향이 있다.

    3. Redis Pub/Sub (레디스 발행/구독)
    Redis의 Pub/Sub 기능은 메시지 전달의 속도에 초점을 맞춘 휘발성 메시징 방식이다.

    장점:
    매우 빠른 성능을 가진다. 인메모리(In-Memory) 기반으로 동작하여 적은 장비로도 높은 성능을 낼 수 있다.
    구조가 간단하여 구축 및 사용이 쉽다.

    단점:
    메시지 유실 가능성이 있다. Redis는 메시지를 영구 저장하지 않는다. 
    따라서 메시지가 유실되어도 상관없는 실시간성 데이터(예: 단순 알림)에만 적합하다. 소비자가 연결되어 있지 않은 상태에서 발행된 메시지는 사라진다.

    카프카(Kafka) 활용 경험
    **분산 시스템 간의 느슨한 결합(Decoupling)**과 비동기 데이터 동기화를 구현하는 대표적인 예시이다.

    1. 생산자(Producer)와 소비자(Consumer) 파악
    생산자 (Producer):
    **본사(메인 회사)의 관리툴 (또는 해당 업데이트를 처리하는 백엔드 서비스)**이다.
    역할: 매장 정보가 수정되는 순간, 이 변경 이벤트를 메시지로 생성하여 카프카의 특정 **토픽(Topic)**으로 발행하는 역할을 한다.

    소비자 (Consumer):
    **각 계열사의 시스템 (매장 장비 정보를 연동받아 클라이언트 정보를 갱신하는 서비스)**이다.
    역할: 카프카의 해당 토픽을 **구독(Consume)**하고, 메시지를 수신할 때마다 자신의 내부 시스템이나 매장 클라이언트 장비 정보를 실제 데이터로 갱신하는 역할을 수행한다.

    2. 비동기 연동 흐름 설명
    이벤트 발생: 본사 관리툴에서 매장 A의 정보가 수정된다.
    메시지 발행: 관리툴 백엔드 서비스는 '매장 A 정보 변경' 메시지를 생성하여 카프카 토픽에 발행한다.
    메인 스레드 해방: 본사 관리툴의 트랜잭션은 즉시 완료되며, 사용자는 빠르게 응답을 받는다. 이 시점에서 본사는 계열사의 처리 성공 여부에 직접적으로 영향을 받지 않는다.
    메시지 처리: 카프카에 연결된 각 계열사의 시스템(소비자)은 이 메시지를 독립적으로 수신한다. 수신 즉시 각 계열사는 자신의 시스템에 맞는 로직으로 매장 A의 클라이언트 장비 정보를 갱신한다.

    3. 실무적 이점 (카프카 선택의 배경)
    이러한 방식은 별도 스레드 실행 방식으로는 해결하기 어려운 복잡한 문제를 해결해 준다.
    느슨한 결합 및 확장 용이성: 본사 시스템은 메시지만 발행하면 된다. 계열사 1, 계열사 2, 계열사 N을 연결할 때 본사 시스템 코드는 전혀 수정할 필요가 없다. 이는 새로운 계열사 추가 시 개발 비용과 위험을 크게 낮춘다.
    시스템 격리와 안정성: 만약 특정 계열사의 시스템에 일시적인 장애가 발생하여 메시지를 처리하지 못하더라도, 본사 시스템은 정상 작동한다. 카프카는 메시지를 영구적으로 보존하므로, 장애가 복구된 후 계열사 시스템은 중단된 시점부터 메시지를 다시 가져와 유실 없이 정보를 동기화할 수 있다.
    부하 분산: 본사에서 갑자기 많은 매장 정보가 수정되어 메시지가 폭주해도, 카프카가 이를 안정적으로 수용하고 계열사는 자신의 처리 능력에 맞춰 메시지를 순차적으로 처리하여 과부하를 방지한다.

3. 트랜잭션 아웃박스 패턴
    아웃박스 테이블의 역할 (트리거)
    아웃박스 테이블은 외부 메시징 시스템(예: 카프카)으로 보내야 할 메시지를 일단 안전하게 보관하는 임시 저장소 역할을 한다.

    트리거 역할: 아웃박스 테이블에 새로운 레코드가 **완전하게 저장(커밋)**되는 행위 자체가 **"이제 외부로 메시지를 전송해야 한다"**는 신뢰할 수 있는 트리거가 된다.

    최종적인 안전한 전송 과정
    이 패턴의 궁극적인 목표는 **DB 트랜잭션의 원자성(Atomicity)**을 활용하여 메시지 유실을 방지하는 것이다.

    원자성 보장 (DB 커밋):
    업무 데이터 변경과 아웃박스 테이블에 메시지 저장 작업을 하나의 트랜잭션으로 처리한다.
    DB에 이 두 값이 **완전하게 저장(Commit)**되었을 때, 비로소 메시지를 전송해도 안전하다는 보장이 생긴다.

    안전한 전송 (Relay Process):
    별도의 릴레이(Relay) 프로세스가 커밋된 아웃박스 테이블의 레코드를 주기적으로 감지하거나 읽어온다.
    릴레이 프로세스는 해당 레코드를 카프카 같은 메시징 시스템에 전송한다.

    유실 방지:
    만약 메시징 시스템으로의 전송이 실패하더라도, 메시지 데이터는 이미 DB에 안전하게 저장되어 있다.
    릴레이 프로세스는 전송에 성공할 때까지 재시도할 수 있으며, 전송이 완료되면 아웃박스 레코드를 삭제하거나 상태를 업데이트하여 메시지 유실을 사실상 막는다.
    요약하면, 아웃박스 테이블은 DB 트랜잭션과 외부 메시징 시스템 사이의 신뢰할 수 있는 다리 역할을 수행한다.

    그렇다면 DB에 저장하고 읽는데 I/O는 많이 안들까?
    많이 든다. 하지만 허용 가능한 트레이드오프로 간주한다. 추가로 뒤에 있을 CDC 기술을 사용하여 읽기 I/O 부하를 최소화 한다.

4. 배치 전송
    배치 연동은 실시간성이 요구되지 않는 통계, 정산, 대규모 데이터 마이그레이션 등에 적합한 가장 고전적이고 확실한 연동 방식이다.
    그래서 보통 사용자가 이용하지 않는 시간대에 진행하곤 한다.

    그러면 글로벌 서비스에는 어떨까?
    어쩔수 없다. 지역별 배치 시간대를 운영하거나 배치 서버를 따로 두어 자원을 격리시켜 분산 처리를 해야한다.

5. CDC
    1. CDC의 기본 
    CDC는 데이터베이스의 **'변경 이력'**을 실시간으로 추적하고 캡처하여, 변경된 데이터를 기반으로 후속 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴이다.
    변경 데이터 추적: CDC는 테이블의 데이터가 INSERT, UPDATE, DELETE될 때 발생하는 모든 변경 사항을 놓치지 않고 포착한다.
    로그 기반 작동: CDC는 일반적인 SELECT 쿼리 방식을 사용하지 않는다. 
    대신 데이터베이스의 트랜잭션 로그(Transaction Log), 즉 MySQL의 Binlog나 PostgreSQL의 **WAL(Write-Ahead Log)**과 같은 DB의 내부 로그 파일을 읽어 들인다.

    그러면 로그를 쌓는 것인가?
    CDC는 로그를 쌓는 느낌이 아니라 이미 DB에 쌓여있는 로그를 읽어서 활용하는 것에 가깝다.
    DB 로그: 모든 DB 변경 작업은 데이터의 정합성을 위해 내부적으로 이 트랜잭션 로그에 먼저 기록된다. 이 로그는 DB 자체의 핵심 기능이다.
    CDC: CDC 도구(예: Debezium)는 이 로그를 실시간으로 분석하여 **"어떤 테이블의 어떤 레코드가 어떻게 바뀌었다"**는 정보를 이벤트 스트림(예: 카프카)으로 만들어 전달한다.

    어떻게 하면 트랜잭션 아웃박스와 최고의 효율을 낼 수 있을까.
    아웃박스 패턴은 메시지를 전송하기 위해 아웃박스 테이블을 계속 조회해야 할때가 있다. 이때 CDC 기술을 도입하면 기다릴 필요가 없어진다. 

    CDC는 아웃박스 테이블의 릴레이 프로세스를 대체하거나 보조하는 역할을 한다.
    아웃박스 패턴은 "무엇을(메시지 데이터)" 보낼지, "언제(DB 커밋 시점)" 보낼지를 결정하는 안전한 쓰기 메커니즘을 제공한다.
    CDC는 이 메시지를 DB에서 가장 효율적이고 비침투적인 방식으로 읽어내어(캡처) 외부로 전송하는 읽기 메커니즘을 제공한다.
    이 둘을 결합하면, 트랜잭션의 일관성을 확보하는 동시에 DB에 부하를 주지 않고 실시간으로 메시지를 전송할 수 있게 된다. 이는 분산 시스템에서 데이터 연동의 가장 진보적이고 안정적인 방식 중 하나이다.


    폴링 방식의 비효율성 예시 (I/O 부하 문제)
    상황 설정
    회사가 트랜잭션 아웃박스 패턴을 사용하고, 메시지 전송을 담당하는 릴레이 프로세스가 폴링(Polling) 방식으로 구현되었다고 가정

    배치 주기
     - 릴레이 프로세스는 1초마다 아웃박스 테이블을 조회하도록 설정되어 있다.

    운영 상황
     - 평상시에는 시간당 3,600건, 즉 1초에 평균 1건의 메시지만 발생한다.

    DB 부하 측정
     - 메시지 유무를 확인하기 위해 매번 SELECT 쿼리를 실행해야 한다.

    1. 메시지가 발생하지 않을 때의 문제
    대부분의 시간 동안 메시지가 발생하지 않는 평시 상황에서의 비효율성이다.

    실제 필요한 조회 횟수
     - 1시간 동안 3,600번 (1건/초 * 3,600초)의 유효한 데이터가 발생

    폴링으로 인한 조회 횟수
     - 릴레이 프로세스는 1시간 동안 3,600번 (1회/초 * 3,600초) 아웃박스 테이블을 조회

    결과
     - 매초마다 DB 서버에 불필요한 연결과 쿼리 실행 부하를 준다. 특히 DB의 트래픽이 높은 피크 타임에는 이 불필요한 쿼리가 메인 비즈니스 로직의 성능을 저해할 수 있다.

    2. 메시지 발생 빈도가 매우 낮을 때의 문제
    만약 하루에 총 10건의 메시지만 발생하는 매우 드문 상황을 가정해 보자.

    실제 필요한 조회 횟수
     - 하루 종일 10번의 유효한 데이터가 발생

    폴링으로 인한 조회 횟수
     - 릴레이 프로세스는 하루 종일 86,400번 (1회/초 * 24시간 * 3,600초) 아웃박스 테이블을 조회

    결과
     - 86,390번의 쿼리가 메시지가 없음을 확인하는 데만 사용된다. 
       이는 99.9% 이상의 불필요한 읽기(Read) I/O 부하를 메인 DB에 집중적으로 유발하게 된다.

    최종 결론
    폴링 방식은 데이터 변경 여부와 관계없이 정해진 시간마다 DB에 강제로 접근하여 읽기 I/O 부하를 준다. 
    이 부하는 비록 한 번의 쿼리 자체는 가볍더라도, 횟수가 누적되면서 운영 시스템의 전반적인 성능 저하와 자원 낭비를 초래한다.

    이 때문에 트랜잭션 아웃박스 패턴에서는 읽기 부하가 거의 없는 CDC 기술을 사용하여, 
    아웃박스 테이블의 쓰기(Write) 작업만 감지하여 메시지를 전송하는 방식으로 이 비효율성을 극복하는 것이다.
