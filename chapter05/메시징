1. Kafka (카프카)
Kafka는 대규모 데이터 스트림 처리에 최적화된 분산 메시징 플랫폼이다.

장점:
높은 처리량을 보인다. 초당 백만 개 이상의 메시지 처리가 가능할 정도로 압도적인 성능을 자랑한다.
수평 확장 용이성이 뛰어나다. 서버(브로커), 파티션, 소비자를 손쉽게 늘려 **수평 확장(Scale-out)**에 매우 유리하다.
메시지를 디스크에 일정 기간 보존하는 영구 저장소 역할을 한다. 이 덕분에 소비자가 메시지를 놓치거나 처리하지 못했을 경우 **다시 처리(Replay)**할 수 있다.

단점:
시스템 구조가 복잡하며, 운영 및 관리에 상대적으로 높은 전문성이 요구된다.

2. RabbitMQ (래빗MQ)
RabbitMQ는 메시지 전송의 신뢰성과 복잡한 라우팅에 중점을 둔 전통적인 메시지 브로커이다.

장점:
높은 신뢰성을 제공하여 메시지 전달 보장이 중요할 때 유용하다. 다양한 메시지 큐 모델(Exchanges)을 지원한다.

단점:
Kafka에 비해 메시지 처리량(Throughput)은 상대적으로 낮다.
운영 환경에서 **많은 자원(Resource)**을 요구하는 경향이 있다.

3. Redis Pub/Sub (레디스 발행/구독)
Redis의 Pub/Sub 기능은 메시지 전달의 속도에 초점을 맞춘 휘발성 메시징 방식이다.

장점:
매우 빠른 성능을 가진다. 인메모리(In-Memory) 기반으로 동작하여 적은 장비로도 높은 성능을 낼 수 있다.
구조가 간단하여 구축 및 사용이 쉽다.

단점:
메시지 유실 가능성이 있다. Redis는 메시지를 영구 저장하지 않는다. 
따라서 메시지가 유실되어도 상관없는 실시간성 데이터(예: 단순 알림)에만 적합하다. 소비자가 연결되어 있지 않은 상태에서 발행된 메시지는 사라진다.

카프카(Kafka) 활용 경험
**분산 시스템 간의 느슨한 결합(Decoupling)**과 비동기 데이터 동기화를 구현하는 대표적인 예시이다.

1. 생산자(Producer)와 소비자(Consumer) 파악
생산자 (Producer):
**본사(메인 회사)의 관리툴 (또는 해당 업데이트를 처리하는 백엔드 서비스)**이다.
역할: 매장 정보가 수정되는 순간, 이 변경 이벤트를 메시지로 생성하여 카프카의 특정 **토픽(Topic)**으로 발행하는 역할을 한다.

소비자 (Consumer):
**각 계열사의 시스템 (매장 장비 정보를 연동받아 클라이언트 정보를 갱신하는 서비스)**이다.
역할: 카프카의 해당 토픽을 **구독(Consume)**하고, 메시지를 수신할 때마다 자신의 내부 시스템이나 매장 클라이언트 장비 정보를 실제 데이터로 갱신하는 역할을 수행한다.

2. 비동기 연동 흐름 설명
이벤트 발생: 본사 관리툴에서 매장 A의 정보가 수정된다.
메시지 발행: 관리툴 백엔드 서비스는 '매장 A 정보 변경' 메시지를 생성하여 카프카 토픽에 발행한다.
메인 스레드 해방: 본사 관리툴의 트랜잭션은 즉시 완료되며, 사용자는 빠르게 응답을 받는다. 이 시점에서 본사는 계열사의 처리 성공 여부에 직접적으로 영향을 받지 않는다.
메시지 처리: 카프카에 연결된 각 계열사의 시스템(소비자)은 이 메시지를 독립적으로 수신한다. 수신 즉시 각 계열사는 자신의 시스템에 맞는 로직으로 매장 A의 클라이언트 장비 정보를 갱신한다.

3. 실무적 이점 (카프카 선택의 배경)
이러한 방식은 별도 스레드 실행 방식으로는 해결하기 어려운 복잡한 문제를 해결해 준다.
느슨한 결합 및 확장 용이성: 본사 시스템은 메시지만 발행하면 된다. 계열사 1, 계열사 2, 계열사 N을 연결할 때 본사 시스템 코드는 전혀 수정할 필요가 없다. 이는 새로운 계열사 추가 시 개발 비용과 위험을 크게 낮춘다.
시스템 격리와 안정성: 만약 특정 계열사의 시스템에 일시적인 장애가 발생하여 메시지를 처리하지 못하더라도, 본사 시스템은 정상 작동한다. 카프카는 메시지를 영구적으로 보존하므로, 장애가 복구된 후 계열사 시스템은 중단된 시점부터 메시지를 다시 가져와 유실 없이 정보를 동기화할 수 있다.
부하 분산: 본사에서 갑자기 많은 매장 정보가 수정되어 메시지가 폭주해도, 카프카가 이를 안정적으로 수용하고 계열사는 자신의 처리 능력에 맞춰 메시지를 순차적으로 처리하여 과부하를 방지한다.
