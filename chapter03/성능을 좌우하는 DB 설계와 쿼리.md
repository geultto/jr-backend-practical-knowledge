# 성능을 좌우하는 DB 설계와 쿼리

## 조회 트래픽을 고려한 인덱스 설계

- 조회 패턴과 트래픽을 고려한 인덱스 설계로 풀 스캔을 방지

### 단일 인덱스와 복합 인덱스

- 상황에 따라 단일 인덱스와 복합 인덱스 중 적절한 선택을 해야 함

### 선택도를 고려한 인덱스 칼럼 선택

- 선택도(selectivity)가 높은 칼럼을 골라 인덱스를 생성해야 조회 효율이 높아짐
- 선택도는 인덱스에서 특정 칼럼의 고유한 값 비율을 나타냄
  - 선택도가 ⬆️ -> 해당 칼럼에 고유한 값이 많음
  - 선택도가 ⬇️ -> 해당 칼럼에 고유한 값이 적음

### 커버링 인덱스 활용하기

- 커버링 인덱스는 특정 쿼리를 실행하는 데 필요한 칼럼을 모두 포함하는 인덱스
- 커버링 인덱스를 사용하는 경우, 실제 데이터를 읽어오는 과정이 생략되므로 쿼리 실행 시간이 빨라짐

### 인덱스는 필요한 만큼만 만들기

```
(userId, activityDate)
(userId, activityDate, activityType)
```

- 여기서 두 번째 인덱스가 효과를 발휘하려면 한 사용자가 하루에 만들어 내는 데이터 개수가 조회 성능에 영향을 줄 만큼 많아야 함
- 효과가 적은 인덱스를 추가하면 오히려 성능이 나빠질 수 있음

  - 인덱스가 추가되면 관리 비용이 증가하고, 메모리와 디스크 사용량도 증가

- 같은 칼럼에 대한 인덱스 또 추가하지 않기
  - 동일한 칼럼을 사용하는 인덱스가 2개 존재한다고 해서 조회 성능이 두 배로 좋아지는 것은 아님
  - 인덱스 관리비용만 증가할 뿐
  - 새로운 인덱스를 추가하기 전에 기존에 어떤 인덱스가 존재하는지, 동일한 효과를 낼 수 있는 다른 인덱스가 있는지 검토하자

---

### 중복 칼럼을 포함한 인덱스의 오해

다음과 같이 중복된 칼럼을 포함한 인덱스가 여러 개 있을 때:

```
idx1: (userId)
idx2: (userId, activityDate)
idx3: (userId, activityDate, activityType)
```

idx3이 idx1과 idx2를 모두 커버할 수 있으니 idx3만 사용하는 것이 효율적이지 않을까 하는 생각을 할 수 있음

하지만 실제로는 그렇지 않다. 다음 쿼리들을 살펴보자:

```
WHERE userId = ?
WHERE userId = ? AND activityDate = ?
```

이론적으로 idx3은 위 쿼리들에서 사용 가능하지만, 가장 효율적인 선택은 아님

**idx3가 idx1을 대체하지 못하는 이유**

- **인덱스 크기 차이 (캐시 효율)**

  - idx1: 매우 작음
  - idx3: activityType까지 포함하여 리프 페이지가 증가

  - `WHERE userId = ?` 같은 핫 경로 쿼리는 작은 인덱스가 항상 더 빠름
  - 특히 COUNT, EXISTS, 단건 확인 같은 쿼리에서는 idx1이 압도적으로 유리함

- **row 수 예측 정확도**
  - idx3는 통계가 더 복잡해져 옵티마이저가 결과 row 수를 과대/과소 예측할 가능성이 높음
  - 이로 인해 가끔 풀 스캔이나 잘못된 인덱스 선택이 발생할 수 있음

**idx3가 idx2를 대체하지 못하는 이유**

- **activityType이 없는 날짜 범위 쿼리**

  ```sql
  SELECT *
  FROM activity
  WHERE userId = ?
    AND activityDate BETWEEN '2024-07-01' AND '2024-07-31';
  ```

  - idx2: 최적의 선택
  - idx3: 사용 가능하지만 activityType이 range 조건에 끼어들어 더 많은 리프 페이지를 탐색해야 함

- **ORDER BY / GROUP BY 안정성**
  ```sql
  WHERE userId = ?
  ORDER BY activityDate DESC
  ```
  - idx2: 정렬 없이 처리 가능 (인덱스 순서와 일치)
  - idx3: 실행 계획이 불안정할 수 있음 (옵티마이저가 최적 경로를 잘못 선택할 가능성)

**정리**
복합 인덱스 하나가 prefix를 포함한다고 해서 더 작은 인덱스를 대체했다고 생각하면 위험하다.

핫 경로·정렬·범위 쿼리는 작고 명확한 인덱스가 훨씬 안정적!

---

### 인덱스 개수와 성능의 관계

일반적으로 인덱스를 많이 등록하거나 인덱스에 중복 칼럼이 많으면 메모리와 디스크 사용량이 증가하기 때문에 인덱스 생성 시 비용을 고려해야 한다고 알려져 있는데;

하지만 대부분의 경우 인덱스를 추가한다고 해서 그 비용이 과도하게 부담되거나 크게 고려할 정도는 아닌 것 같음

그럼 어떤 기준으로 이걸 인덱스를 관리해야하나...?

- **인덱스 증가 시 디스크 사용량**

  InnoDB 기준 보조 인덱스 크기 공식(근사치):

  ```
  (인덱스 컬럼 크기 합 + PK 크기 + 오버헤드) × row 수 × 1.2~1.4
  ```

- **예시**

  - row 수: 1,000,000
  - PK: BIGINT = 8B

  - **(userId) 인덱스**

    - userId(8B) + PK(8B) ≈ 16B
    - → 약 20~25MB

  - **(userId, activityDate) 인덱스**

    - 8B + 8B + 8B ≈ 24B
    - → 약 30~35MB

  - **(userId, activityDate, activityType VARCHAR(20)) 인덱스**
    - activityType 평균 10B
    - → 약 45~60MB

  문자열 칼럼을 추가할 때마다 인덱스 크기가 급격히 증가한다.

  **이유:** 숫자 타입은 고정 크기(8B, 4B)로 저장되지만, 문자열은 가변 길이로 저장되어 최대 길이까지 저장될 수 있고 문자 인코딩에 따라 크기가 달라지기 때문이다.

- **인덱스 증가 시 메모리 사용량**

  인덱스가 증가한다고 해서 메모리 사용량이 그만큼 선형적으로 증가하지는 않는다.

  실제 동작 방식:

  - 디스크에는 인덱스 전체가 100% 저장됨
  - 메모리(버퍼풀)에는 자주 사용되는 페이지만 로드됨

  - 사용되지 않는 인덱스 → 메모리 사용량 거의 없음
  - 핫 인덱스 → 버퍼풀 점유

  따라서 메모리 사용량은 선형 증가가 아니라 실제 사용 패턴에 따라 달라진다.

- **메모리·디스크 비용을 고려하는 이유**

  비용을 고려해야 하는 이유는 미래의 임계점 때문

- **임계점 도달 시**

  - row 수가 많아지고, 인덱스도 많아지고, 문자열 인덱스가 많아지면
    - 인덱스 전체 크기 > 버퍼풀 크기
    - 캐시 미스 급증
    - 디스크 IO 폭증

- **실제 관리해야 할 핵심: `쓰기 성능`**

  결국 인덱스는 읽기 성능을 위해 추가하지만, 많아질 수록 쓰기 성능이 안좋아진다

  - **읽기**: 인덱스가 있으면 거의 항상 성능이 개선됨
  - **쓰기**: 인덱스가 하나 추가될 때마다 비용이 무조건 증가함

  얼마나 추가할지, 언제까지 추가할지의 관건은 쓰기 성능을 고려한 판단이 필요

- **인덱스 과잉의 신호**

  | 신호                       | 의미                    |
  | -------------------------- | ----------------------- |
  | INSERT/UPDATE latency 증가 | 인덱스 과잉 가능성      |
  | CPU 사용량 ↑               | B-tree 재조정 비용 증가 |
  | innodb_log_waits 증가      | flush 압박              |
  | 디스크 write IOPS ↑        | 인덱스 갱신 비용 증가   |

- **결론**

  - 인덱스가 증가하면 쓰기 성능을 고려하여 인덱스 수를 관리해야 한다.

  - **쓰기 부하가 있는 테이블에서는 "읽기를 빠르게 해주는 인덱스"보다 "쓰기를 망치지 않는 최소 인덱스"가 더 중요해지는 순간이 온다.**

## 몇 가지 조회 성능 개선 방법

- 미리 집계하기
  - 집계 데이터를 미리 계산해서 별도 칼럼에 저장
- 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용
  - 오프셋 만큼 데이터를 세는 과정이 생략됨
- 조회 범위를 시간 기준으로 제한
- 전체 개수 세지 않기
- 오래된 데이터 삭제 및 분리 보관하기
- DB 장비 확장하기

> 개발/운영 환경 간 DB 사양 차이로 인한 성능 문제 대비 어떻게...?
