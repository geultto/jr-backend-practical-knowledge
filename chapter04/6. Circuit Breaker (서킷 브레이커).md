## Circuit Breaker가 필요한 이유

### 문제 상황: 장애 전파

```mermaid
sequenceDiagram
    participant User as 사용자
    participant A as A 서비스
    participant B as B 서비스 (장애)

    User->>A: 요청 1
    A->>B: API 호출
    Note over B: 응답 없음 (장애)
    Note over A: Read Timeout (5초) 대기
    A-->>User: 5초 후 에러

    User->>A: 요청 2
    A->>B: API 호출
    Note over B: 응답 없음
    Note over A: Read Timeout (5초) 대기
    A-->>User: 5초 후 에러

    Note over A: 스레드 풀 고갈
    Note over A: A 서비스까지 장애
```

**문제점**

1. **불필요한 재시도**: 장애가 명백한데도 계속 호출 시도
2. **리소스 낭비**: 실패할 요청에 스레드와 시간 소비
3. **장애 전파**: B 서비스 장애가 A 서비스로 확산
4. **복구 지연**: B 서비스가 복구되어도 계속되는 부하로 재장애

### Circuit Breaker의 해결책

```mermaid
sequenceDiagram
    participant User as 사용자
    participant A as A 서비스<br/>(Circuit Breaker)
    participant B as B 서비스 (장애)

    Note over A: CLOSED 상태

    User->>A: 요청 1
    A->>B: API 호출
    Note over B: 응답 없음
    Note over A: 실패 카운트 증가
    A-->>User: 5초 후 에러

    User->>A: 요청 2~10
    A->>B: API 호출
    Note over B: 계속 응답 없음
    Note over A: 실패율 50% 도달

    Note over A: ⚡ OPEN 상태 전환

    User->>A: 요청 11
    Note over A: 즉시 거부 (호출 안 함)
    A-->>User: CallNotPermittedException<br/>(0.1초)

    Note over A,B: 60초 대기 (waitDurationInOpenState)

    Note over A: HALF_OPEN 상태 전환

    User->>A: 요청 (테스트)
    A->>B: 제한적 호출
    Note over B: 복구됨
    B-->>A: 성공
    A-->>User: 성공

    Note over A: ✅ CLOSED 상태 복귀
```

**효과**

1. **빠른 실패(Fail Fast)**: 장애 서비스 호출 중단, 즉시 에러 반환
2. **리소스 보호**: 스레드와 시간 낭비 방지
3. **장애 격리**: A 서비스 정상 동작 유지
4. **자동 복구 시도**: 일정 시간 후 자동으로 재시도

---

## Circuit Breaker 상태 머신

```mermaid
stateDiagram-v2
    [*] --> CLOSED

    CLOSED --> OPEN: 실패율 임계값 초과<br/>(failureRateThreshold)
    OPEN --> HALF_OPEN: 대기 시간 경과<br/>(waitDurationInOpenState)
    HALF_OPEN --> CLOSED: 테스트 호출 성공
    HALF_OPEN --> OPEN: 테스트 호출 실패

    note right of CLOSED
        정상 상태
        - 모든 요청 허용
        - 실패율 추적
        - 슬라이딩 윈도우로 통계 수집
    end note

    note right of OPEN
        차단 상태
        - 모든 요청 즉시 거부
        - CallNotPermittedException 발생
        - 백엔드 서비스 복구 시간 확보
    end note

    note right of HALF_OPEN
        테스트 상태
        - 제한된 요청만 허용
        - 복구 여부 확인
        - 성공 시 CLOSED, 실패 시 OPEN
    end note
```

### 상태별 동작

#### 1. CLOSED (정상)

- **동작**: 모든 요청을 백엔드로 전달
- **추적**: 슬라이딩 윈도우로 성공/실패율 기록
- **전환 조건**: 실패율이 임계값 초과 시 OPEN으로 전환

```java
// CLOSED 상태에서의 동작
if (circuitBreaker.getState() == CLOSED) {
    try {
        Result result = backendService.call();
        circuitBreaker.recordSuccess();  // 성공 기록
        return result;
    } catch (Exception e) {
        circuitBreaker.recordFailure();  // 실패 기록

        // 실패율 계산 (슬라이딩 윈도우 기반)
        if (failureRate > failureRateThreshold) {
            circuitBreaker.transitionToOpen();  // OPEN 전환
        }
        throw e;
    }
}
```

#### 2. OPEN (차단)

- **동작**: 모든 요청을 즉시 거부 (백엔드 호출 안 함)
- **예외**: `CallNotPermittedException` 발생
- **전환 조건**: `waitDurationInOpenState` 시간 경과 후 HALF_OPEN으로 전환

```java
// OPEN 상태에서의 동작
if (circuitBreaker.getState() == OPEN) {
    // 백엔드 호출 없이 즉시 거부
    throw new CallNotPermittedException("Circuit Breaker is OPEN");
}

// 일정 시간 후 자동 전환
if (System.currentTimeMillis() - openStateStartTime > waitDurationInOpenState) {
    circuitBreaker.transitionToHalfOpen();
}
```

#### 3. HALF_OPEN (테스트)

- **동작**: 제한된 수의 요청만 허용 (`permittedNumberOfCallsInHalfOpenState`)
- **목적**: 백엔드 서비스 복구 여부 확인
- **전환 조건**:
  - 테스트 호출 성공 → CLOSED
  - 실패율 임계값 초과 → OPEN

```java
// HALF_OPEN 상태에서의 동작
if (circuitBreaker.getState() == HALF_OPEN) {
    if (callsInHalfOpenState < permittedNumberOfCallsInHalfOpenState) {
        try {
            Result result = backendService.call();
            circuitBreaker.recordSuccess();
            callsInHalfOpenState++;

            // 모든 테스트 호출 성공 시
            if (allCallsSuccessful()) {
                circuitBreaker.transitionToClosed();  // CLOSED 전환
            }
            return result;
        } catch (Exception e) {
            circuitBreaker.recordFailure();
            circuitBreaker.transitionToOpen();  // 다시 OPEN
            throw e;
        }
    } else {
        // 허용된 호출 수 초과
        throw new CallNotPermittedException("Too many calls in HALF_OPEN");
    }
}
```

---

## Resilience4j 주요 프로퍼티

```yaml
resilience4j:
  circuitbreaker:
    instances:
      bService:
        # 1. 슬라이딩 윈도우 설정
        sliding-window-type: COUNT_BASED          # COUNT_BASED | TIME_BASED
        sliding-window-size: 100                  # 최근 100개 호출 추적
        minimum-number-of-calls: 10               # 최소 10개 호출 후 통계 계산

        # 2. 실패 임계값
        failure-rate-threshold: 50                # 실패율 50% 초과 시 OPEN
        slow-call-rate-threshold: 50              # 느린 호출 50% 초과 시 OPEN
        slow-call-duration-threshold: 2s          # 2초 이상이면 "느린 호출"

        # 3. OPEN 상태 설정
        wait-duration-in-open-state: 60s          # OPEN → HALF_OPEN 전환 대기 시간

        # 4. HALF_OPEN 상태 설정
        permitted-number-of-calls-in-half-open-state: 10  # 테스트 호출 수

        # 5. 예외 처리
        record-exceptions:                        # 실패로 기록할 예외
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignore-exceptions:                        # 무시할 예외 (통계에서 제외)
          - com.example.BusinessException
```
