### 요구사항

- 어플리케이션이 1분 간격으로 작업 실행
- 어플리케이션 프로세스는 여러 노드에서 실행됨
- 동시에 여러 스레드가 작업을 실행하면 데이터에 문제가 발생
- Redis, Zookeeper 사용하지 않는다고 가정

- SELECT FOR UPDATE를 이용해서 구현

```java
public record LockOwner(String owner, LocalDateTime expiry) {
    public boolean isOwnedBy(String owner) {
        return this.owner.equals(owner);
    }
    
    public boolean isExpired() {
        return expiry.isBefore(LocalDateTime.now());
    }
}

```

```java
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.LocalDateTime;

public class DistLock {
    private final DataSource dataSource;

    public DistLock(DataSource dataSource) {
        this.dataSource = dataSource;
    }

		// 락 획득 시도 메서드
    public boolean tryLock(String name, String owner, Duration duration) {

        boolean owned;
        try (Connection connection = dataSource.getConnection()) {
            connection.setAutoCommit(false);
            LockOwner lockOwner = getLockOwner(connection, name);
            if (lockOwner == null || lockOwner.owner() == null) {
                insertLockOwner(connection, name, owner, duration);
                owned = true;
            } else {
                owned = false;
            }
            connection.commit();
        } catch (Exception e) {
            owned = false;
        }
        return owned;
    }

		// 락 획득 시 저장
    private void insertLockOwner(Connection connection, String name, String ownerId, Duration duration) throws SQLException {
        try (PreparedStatement ps = connection.prepareStatement("INSERT INTO dist_lock values(?, ?, ?)")) {
            ps.setString(1, name);
            ps.setString(2, ownerId);
            ps.setTimestamp(3, getExpiry(duration));
            ps.executeUpdate();
        }
    }

    private static Timestamp getExpiry(Duration duration) {
        return Timestamp.valueOf(LocalDateTime.now().plusSeconds(duration.toSeconds()));
    }

		//락 획득
    private LockOwner getLockOwner(Connection conn, String name) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM dist_lock WHERE name = ? FOR UPDATE")) {
            ps.setString(1, name);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return new LockOwner(rs.getString("name"), rs.getTimestamp("expiry").toLocalDateTime());
                }
            }
        }
        return null;
    }
}
```

etc) 실제로 면접에서 RDB만으로 선착순 기능 구현하는 법을 물어본 적이 있었음

- 당시에 SELECT FOR UPDATE만 생각났는데 혹시 비슷한 면접 질문을 받아본 적이 있는지?

- 정수님 코멘트
  - validation 처리로 동시성을 보장하기 위해 원자적 연산 사용 
    1. 이벤트 히스토리에 유저가 상품 받았는지 체크 
    2. 이벤트 히스토리에 유저 정보 insert
    3. 남은 상품 개수 체크
    4. 이벤트 히스토리를 조회하여 유저가 이미 상품을 받았는지 카운트
    5. 경품 발급
    6. 이벤트 히스토리 테이블에 상품 지급 여부 update
###